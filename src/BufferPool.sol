// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol";
import { OptionsBuilder } from "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol";
import { SendParam, MessagingFee, OFTReceipt } from "@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol";
import { IStargate } from "./interfaces/IStargate.sol";
import "./interfaces/IFiat24Account.sol";
import "./interfaces/IFiat24CryptoRelay.sol";

/**
 * @title BufferPool
 * @notice Source chain contract for Fiat24 token to USDC onramp with cross-chain bridge support via Stargate V2
 * @dev Implements FX calculations with AccessControl
 */
contract BufferPool is 
    Initializable, 
    AccessControlUpgradeable, 
    PausableUpgradeable, 
    ReentrancyGuardUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using OptionsBuilder for bytes;

    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    bytes32 public constant CASH_OPERATOR_ROLE = keccak256("CASH_OPERATOR_ROLE");
    bytes32 public constant OPERATOR_ADMIN_ROLE = keccak256("OPERATOR_ADMIN_ROLE");
    bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256("LIQUIDITY_MANAGER_ROLE");
    bytes32 public constant DELEGATE_OPERATOR_ROLE = keccak256("DELEGATE_OPERATOR_ROLE");
    bytes32 public constant LIQUIDITY_MANAGER_ROBOT_ROLE = keccak256("LIQUIDITY_MANAGER_ROBOT_ROLE");
    bytes32 public constant PAUSE_ROLE = keccak256("PAUSE_ROLE");
    bytes32 public constant UNPAUSE_ROLE = keccak256("UNPAUSE_ROLE");


    // basis points, 10000 = 100%
    uint256 public constant BASIS_POINTS = 10000;
    // Decimal precision adjustment: USDC(6) - Fiat24(2) = 4, so 10^4 = 10000
    uint256 public constant DECIMAL_ADJUSTMENT = 10000;

    // Native token marker addresses
    address public constant NATIVE_ETH = address(0);
    address public constant NATIVE_ETH_ALIAS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    
    // Treasury account token ID for fiat token withdrawal
    uint256 public constant TREASURY_ACCOUNT_ID = 9102;
    
    /// @notice Parameters for local onramp (Fiat24 token -> USDC)
    struct OnrampParams {
        address user;
        address tokenIn;      // Fiat24 token (USD24, EUR24, CHF24, CNH24, SGD24, HKD24, JPY24)
        uint256 amountIn;
        uint256 minAmountOut; // Minimum USDC output
        uint256 feeAmount;    // Fee amount in USDC to send to feeReceiver
    }

    /// @notice Parameters for cross-chain onramp (Fiat24 token -> USDC -> bridge -> destination swap)
    struct CrossChainOnrampParams {
        address user;
        address tokenIn;            // Fiat24 token
        uint256 amountIn;
        uint256 minAmountOut;       // Minimum USDC after FX conversion
        uint256 feeAmount;          // Fee amount in USDC to send to feeReceiver (on source chain)
        uint32 dstEid;              // Destination chain endpoint ID
        address dstAggregator;      // Aggregator on destination chain
        address dstTokenOut;        // Target token on destination chain
        address dstReceiver;        // Final receiver on destination chain
        bytes dstSwapCalldata;      // Generated by frontend/backend via 1inch/Odos
        uint256 dstMinAmountOut;    // Minimum output on destination chain
        uint128 dstGasLimit;        // Gas limit for compose call
        uint256 bridgeMinAmount;    // Minimum USDC to receive on bridge (slippage)
    }

    /// @notice Payload for destination chain swap (USDC -> target crypto)
    struct DstSwapPayload {
        address user;
        address tokenOut;
        uint256 minAmountOut;
        address aggregator;
        bytes swapCalldata;
        address srcTokenIn;     // Source chain input token (Fiat24 token)
        uint256 srcAmountIn;    // Source chain input amount
    }

    /// @notice EIP-2612 permit signature parameters
    struct PermitParams {
        uint256 deadline;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    /// @notice Parameters for swapUsdcToToken
    struct SwapParams {
        uint256 usdcAmount;     // Amount of USDC to swap
        uint256 feeAmount;      // Fee amount in USDC to send to feeReceiver
        address tokenOut;       // Target output token
        uint256 minAmountOut;   // Minimum output amount (slippage protection)
        address aggregator;     // Aggregator contract (must be whitelisted)
        bytes swapCalldata;     // Calldata for aggregator
    }
    
    // Core tokens
    IERC20Upgradeable public usdc;
    // Keep for getQuote logic branch
    address public usd24;  

    // Stargate integration
    IStargate public stargate;
    // dstEid => BufferPoolDst address
    mapping(uint32 => address) public dstOnrampReceivers;  
    uint128 public defaultDstGasLimit;

    // Fee configuration, // 0.5% = 50 bps
    uint256 public bufferPoolFee;     

    // Fiat24 Account for user validation
    IFiat24Account public fiat24Account;

    // Fiat24CryptoRelay for exchange rates
    IFiat24CryptoRelay public fiat24CryptoRelay;

    // Fixed receiver for liquidity withdrawals
    address public liquidityReceiver;

    // Fee receiver address
    address public feeReceiver;

    // Valid Fiat24 tokens for onramp
    mapping(address => bool) public validXXX24Tokens;

    // Aggregator whitelist for swap execution
    mapping(address => bool) public whitelistedAggregators;
    // Whitelisted function selectors for each aggregator
    mapping(address => mapping(bytes4 => bool)) public whitelistedSelectors;

    event OnrampExecuted(
        address indexed user,
        address indexed tokenIn,
        uint256 amountIn,
        uint256 usdcOut
    );

    event OnrampAndSwapExecuted(
        address indexed user,
        address indexed tokenIn,
        uint256 amountIn,
        uint256 usdcOut,
        address tokenOut,
        uint256 amountOut
    );

    event OnrampAndBridgeInitiated(
        address indexed user,
        address indexed tokenIn,
        uint256 amountIn,
        uint256 usdcOut,
        uint32 dstEid,
        address dstReceiver,
        address dstAggregator,
        address dstTokenOut,
        uint256 dstMinAmountOut
    );

    event LiquidityAdded(address indexed provider, uint256 amount);
    event LiquidityRemoved(address indexed receiver, uint256 amount);
    event FeesUpdated(uint256 oldFee, uint256 newFee);
    event DstOnrampReceiverUpdated(uint32 indexed dstEid, address oldReceiver, address newReceiver);
    event LiquidityReceiverUpdated(address oldReceiver, address newReceiver);
    event CryptoRelayUpdated(address oldRelay, address newRelay);
    event StargateUpdated(address oldStargate, address newStargate);
    event DefaultDstGasLimitUpdated(uint128 oldGasLimit, uint128 newGasLimit);
    event Fiat24TokenValidityUpdated(address indexed token, bool oldValid, bool newValid);
    event SwapExecuted(address indexed user, address indexed tokenOut, uint256 usdcIn, uint256 amountOut);
    event AggregatorWhitelistUpdated(address indexed aggregator, bool isWhitelisted);
    event FunctionSelectorWhitelisted(address indexed aggregator, bytes4 indexed selector, bool isWhitelisted);
    event FeeCollected(address indexed user, uint256 feeAmount);
    event FeeReceiverUpdated(address oldReceiver, address newReceiver);
    event BufferPoolFeeCollected(address indexed user, uint256 feeAmount);
    event PermitFailed(address indexed user, address indexed token, uint256 amount);
    event FiatTokenConverted(address indexed tokenIn, uint256 amountIn, uint256 usd24Out);
    event FiatTokensWithdrawn(address indexed token, address indexed recipient, uint256 amount);

    error BufferPool__InvalidToken();              // 0x43e33e01
    error BufferPool__InvalidAmount();             // 0x24d6b90a
    error BufferPool__SlippageExceeded();          // 0x86ef9cfc
    error BufferPool__ZeroAddress();               // 0x82f5c6af
    error BufferPool__NoChange();                  // 0x5c5a1c4f
    error BufferPool__AccountNotLive();            // 0x33ded572
    error BufferPool__InvalidDstEid();             // 0xde41abe5
    error BufferPool__NotWhitelistedAggregator();  // 0x546c7143
    error BufferPool__FunctionNotWhitelisted();    // 0x6cfce88e
    error BufferPool__SwapFailed();                // 0xfe8d118a
    error BufferPool__NativeTransferFailed();      // 0x8d34517a
    error BufferPool__AccountNotSupport();         // 0x42d31f1c
    error BufferPool__InvalidReceiver();           // 0x1ca6b843

    function initialize(
        address _admin,
        address _usdc,
        address _usd24,
        address _stargate,
        address _fiat24Account,
        address _fiat24CryptoRelay,
        address _liquidityReceiver,
        address[] calldata _validXXX24Tokens
    ) public initializer {
        if (_admin == address(0) || _usdc == address(0) || _usd24 == address(0) || 
            _stargate == address(0) || _fiat24Account == address(0) || 
            _fiat24CryptoRelay == address(0) || _liquidityReceiver == address(0)) {
            revert BufferPool__ZeroAddress();
        }

        __AccessControl_init();
        __Pausable_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, _admin);
        _grantRole(OPERATOR_ADMIN_ROLE, _admin);

        usdc = IERC20Upgradeable(_usdc);
        usd24 = _usd24;
        stargate = IStargate(_stargate);
        fiat24Account = IFiat24Account(_fiat24Account);
        fiat24CryptoRelay = IFiat24CryptoRelay(_fiat24CryptoRelay);
        liquidityReceiver = _liquidityReceiver;
        feeReceiver = _liquidityReceiver;

        // Default fee setting: 0.5%
        bufferPoolFee = 50;   

        // Default gas limit for cross-chain compose
        defaultDstGasLimit = 500_000;

        // Initialize valid Fiat24 tokens (USD24, EUR24, CHF24, CNH24, SGD24, HKD24, JPY24)
        if (_validXXX24Tokens.length == 0) revert BufferPool__InvalidAmount();
        for (uint256 i = 0; i < _validXXX24Tokens.length; i++) {
            if (_validXXX24Tokens[i] == address(0)) revert BufferPool__ZeroAddress();
            validXXX24Tokens[_validXXX24Tokens[i]] = true;
        }
    }

    /**
     * @notice Execute a local onramp: Fiat24 token -> USDC
     * @param params Onramp parameters
     */
    function onramp(OnrampParams calldata params) 
        external 
        nonReentrant 
        whenNotPaused 
        onlyRole(DELEGATE_OPERATOR_ROLE)
    {
        if (params.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(params.user);

        // Transfer Fiat24 token from user
        IERC20Upgradeable(params.tokenIn).safeTransferFrom(
            params.user,
            address(this),
            params.amountIn
        );

        // Calculate USDC output with fee breakdown
        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(params.tokenIn, params.amountIn);
        uint256 userAmount = _deductFeeAndValidate(usdcOut, params.feeAmount, params.minAmountOut, params.user);

        // Collect buffer pool fee to liquidityReceiver
        _collectBufferPoolFee(poolFeeAmount, params.user);

        // Transfer USDC to user
        usdc.safeTransfer(params.user, userAmount);

        emit OnrampExecuted(params.user, params.tokenIn, params.amountIn, userAmount);
    }

    /**
     * @notice Execute a local onramp with permit: Fiat24 token -> USDC
     * @param params Onramp parameters
     * @param permit Permit signature parameters
     */
    function permitAndOnramp(
        OnrampParams calldata params,
        PermitParams calldata permit
    ) 
        external 
        nonReentrant 
        whenNotPaused 
        onlyRole(CASH_OPERATOR_ROLE)
    {
        if (params.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(params.user);

        // Execute permit
        try IERC20PermitUpgradeable(params.tokenIn).permit(
            params.user, address(this), params.amountIn,
            permit.deadline, permit.v, permit.r, permit.s
        ) {} catch {
            emit PermitFailed(params.user, params.tokenIn, params.amountIn);
        }

        // Transfer Fiat24 token from user
        IERC20Upgradeable(params.tokenIn).safeTransferFrom(
            params.user,
            address(this),
            params.amountIn
        );

        // Calculate USDC output with fee breakdown
        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(params.tokenIn, params.amountIn);
        uint256 userAmount = _deductFeeAndValidate(usdcOut, params.feeAmount, params.minAmountOut, params.user);

        // Collect buffer pool fee to liquidityReceiver
        _collectBufferPoolFee(poolFeeAmount, params.user);

        // Transfer USDC to user
        usdc.safeTransfer(params.user, userAmount);

        emit OnrampExecuted(params.user, params.tokenIn, params.amountIn, userAmount);
    }

    /**
     * @notice Execute a cross-chain onramp: Fiat24 token -> USDC -> bridge -> destination swap
     * @dev Uses Stargate taxi() method for composability.
     * @param params Cross-chain onramp parameters including destination swap details
     */
    function onrampAndBridge(CrossChainOnrampParams calldata params)
        external
        payable
        nonReentrant
        whenNotPaused
        onlyRole(DELEGATE_OPERATOR_ROLE)
    {
        if (params.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(params.user);

        // Transfer Fiat24 token from user
        IERC20Upgradeable(params.tokenIn).safeTransferFrom(
            params.user,
            address(this),
            params.amountIn
        );

        // Calculate USDC output with fee breakdown
        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(params.tokenIn, params.amountIn);
        uint256 bridgeAmount = _deductFeeAndValidate(usdcOut, params.feeAmount, params.minAmountOut, params.user);

        // Collect buffer pool fee to liquidityReceiver
        _collectBufferPoolFee(poolFeeAmount, params.user);

        _sendCrossChain(params, bridgeAmount);

        emit OnrampAndBridgeInitiated(
            params.user,
            params.tokenIn,
            params.amountIn,
            bridgeAmount,
            params.dstEid,
            params.dstReceiver,
            params.dstAggregator,
            params.dstTokenOut,
            params.dstMinAmountOut
        );
    }

    /**
     * @notice Execute a cross-chain onramp with permit: Fiat24 token -> USDC -> bridge -> destination swap
     * @param params Cross-chain onramp parameters including destination swap details
     * @param permit Permit signature parameters
     */
    function permitAndOnrampAndBridge(
        CrossChainOnrampParams calldata params,
        PermitParams calldata permit
    )
        external
        payable
        nonReentrant
        whenNotPaused
        onlyRole(CASH_OPERATOR_ROLE)
    {
        if (params.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(params.user);

        // Execute permit
        try IERC20PermitUpgradeable(params.tokenIn).permit(
            params.user, address(this), params.amountIn,
            permit.deadline, permit.v, permit.r, permit.s
        ) {} catch {
            emit PermitFailed(params.user, params.tokenIn, params.amountIn);
        }

        // Transfer Fiat24 token from user
        IERC20Upgradeable(params.tokenIn).safeTransferFrom(
            params.user,
            address(this),
            params.amountIn
        );

        // Calculate USDC output with fee breakdown
        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(params.tokenIn, params.amountIn);
        uint256 bridgeAmount = _deductFeeAndValidate(usdcOut, params.feeAmount, params.minAmountOut, params.user);

        // Collect buffer pool fee to liquidityReceiver
        _collectBufferPoolFee(poolFeeAmount, params.user);

        _sendCrossChain(params, bridgeAmount);

        emit OnrampAndBridgeInitiated(
            params.user,
            params.tokenIn,
            params.amountIn,
            bridgeAmount,
            params.dstEid,
            params.dstReceiver,
            params.dstAggregator,
            params.dstTokenOut,
            params.dstMinAmountOut
        );
    }

    /**
     * @notice Onramp fiat token and swap to target crypto in one transaction
     * @param onrampParams Onramp parameters
     * @param swapParams Swap parameters
     */
    function onrampAndSwap(
        OnrampParams calldata onrampParams,
        SwapParams calldata swapParams
    ) external nonReentrant whenNotPaused onlyRole(DELEGATE_OPERATOR_ROLE) {
        if (onrampParams.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(onrampParams.user);

        IERC20Upgradeable(onrampParams.tokenIn).safeTransferFrom(onrampParams.user, address(this), onrampParams.amountIn);

        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(onrampParams.tokenIn, onrampParams.amountIn);
        if (usdcOut < onrampParams.minAmountOut) revert BufferPool__SlippageExceeded();

        _collectBufferPoolFee(poolFeeAmount, onrampParams.user);

        uint256 feeAmount = onrampParams.feeAmount > 0 ? onrampParams.feeAmount : swapParams.feeAmount;
        uint256 amountOut = _onrampSwapOrTransfer(onrampParams.user, usdcOut, feeAmount, swapParams);

        emit OnrampAndSwapExecuted(onrampParams.user, onrampParams.tokenIn, onrampParams.amountIn, usdcOut, swapParams.tokenOut, amountOut);
    }

    /**
     * @notice Onramp fiat token with permit and swap to target crypto
     * @param onrampParams Onramp parameters
     * @param onrampPermit Permit for fiat token
     * @param swapParams Swap parameters
     */
    function permitAndOnrampAndSwap(
        OnrampParams calldata onrampParams,
        PermitParams calldata onrampPermit,
        SwapParams calldata swapParams
    ) external nonReentrant whenNotPaused onlyRole(CASH_OPERATOR_ROLE) {
        if (onrampParams.amountIn == 0) revert BufferPool__InvalidAmount();
        _validateUserAccount(onrampParams.user);

        // Execute permit for fiat token
        try IERC20PermitUpgradeable(onrampParams.tokenIn).permit(
            onrampParams.user, address(this), onrampParams.amountIn,
            onrampPermit.deadline, onrampPermit.v, onrampPermit.r, onrampPermit.s
        ) {} catch {
            emit PermitFailed(onrampParams.user, onrampParams.tokenIn, onrampParams.amountIn);
        }

        // Transfer Fiat24 token from user
        IERC20Upgradeable(onrampParams.tokenIn).safeTransferFrom(
            onrampParams.user,
            address(this),
            onrampParams.amountIn
        );

        // Calculate USDC output with fee breakdown
        (uint256 usdcOut, uint256 poolFeeAmount) = _getQuoteWithFee(onrampParams.tokenIn, onrampParams.amountIn);
        if (usdcOut < onrampParams.minAmountOut) revert BufferPool__SlippageExceeded();

        // Collect buffer pool fee to liquidityReceiver
        _collectBufferPoolFee(poolFeeAmount, onrampParams.user);

        // Use whichever feeAmount is non-zero (onrampParams takes priority)
        uint256 feeAmount = onrampParams.feeAmount > 0 ? onrampParams.feeAmount : swapParams.feeAmount;
        uint256 amountOut = _onrampSwapOrTransfer(onrampParams.user, usdcOut, feeAmount, swapParams);

        emit OnrampAndSwapExecuted(onrampParams.user, onrampParams.tokenIn, onrampParams.amountIn, usdcOut, swapParams.tokenOut, amountOut);
    }

    /**
     * @notice Get quote for Fiat24 token to USDC conversion
     * @dev Handles decimal conversion: Fiat24 tokens have 2 decimals, USDC has 6 decimals
     * @param tokenIn Input Fiat24 token address
     * @param amountIn Input amount (in Fiat24 token decimals, i.e. 2 decimals)
     * @return usdcOut Output USDC amount after fees (in USDC decimals, i.e. 6 decimals)
     */
    function getQuote(address tokenIn, uint256 amountIn) public view returns (uint256 usdcOut) {
        (usdcOut, ) = _getQuoteWithFee(tokenIn, amountIn);
    }

    /**
     * @notice Internal function to get quote with fee breakdown
     * @param tokenIn Input Fiat24 token address
     * @param amountIn Input amount (in Fiat24 token decimals, i.e. 2 decimals)
     * @return netUsdcOut Output USDC amount after buffer pool fee
     * @return poolFeeAmount Buffer pool fee amount in USDC
     */
    function _getQuoteWithFee(address tokenIn, uint256 amountIn) internal view returns (uint256 netUsdcOut, uint256 poolFeeAmount) {
        if (!validXXX24Tokens[tokenIn]) revert BufferPool__InvalidToken();
        
        uint256 grossUsdcOut;
        
        if (tokenIn == usd24) {
            // USD24 -> USDC: Get rate from Fiat24CryptoRelay
            uint256 usdcUsd24Rate = fiat24CryptoRelay.exchangeRates(address(usdc), usd24);
            // USD24 -> USDC rate is inverse: 10000^2 / usdcUsd24Rate
            uint256 usd24UsdcRate = (BASIS_POINTS * BASIS_POINTS) / usdcUsd24Rate;
            // Calculate gross amount (before buffer pool fee)
            grossUsdcOut = (amountIn * DECIMAL_ADJUSTMENT * usd24UsdcRate) / BASIS_POINTS;
        } else {
            // Get FX rate and spread from Fiat24CryptoRelay
            uint256 exchangeRate = fiat24CryptoRelay.getExchangeRate(tokenIn, usd24);
            uint256 spread = fiat24CryptoRelay.getSpread(tokenIn, usd24, false);
            
            // Convert to USD24 amount: amountIn * rate / 10000 * spread / 10000
            uint256 usdAmount = (amountIn * exchangeRate * spread) / (BASIS_POINTS * BASIS_POINTS);
            
            // Then convert USD24 to USDC with decimal adjustment (2 -> 6 decimals)
            uint256 usdcUsd24Rate = fiat24CryptoRelay.exchangeRates(address(usdc), usd24);
            uint256 usd24UsdcRate = (BASIS_POINTS * BASIS_POINTS) / usdcUsd24Rate;
            // Calculate gross amount (before buffer pool fee)
            grossUsdcOut = (usdAmount * DECIMAL_ADJUSTMENT * usd24UsdcRate) / BASIS_POINTS;
        }
        
        // Calculate fee and net amount directly from gross (no precision loss from reverse calculation)
        poolFeeAmount = (grossUsdcOut * bufferPoolFee) / BASIS_POINTS;
        netUsdcOut = grossUsdcOut - poolFeeAmount;
    }

    /**
     * @notice Add USDC liquidity to the pool
     * @param amount Amount of USDC to add
     */
    function addLiquidity(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {
        usdc.safeTransferFrom(msg.sender, address(this), amount);
        emit LiquidityAdded(msg.sender, amount);
    }

    /**
     * @notice Remove USDC liquidity from the pool to liquidityReceiver
     * @param amount Amount of USDC to remove
     */
    function removeLiquidity(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {
        usdc.safeTransfer(liquidityReceiver, amount);
        emit LiquidityRemoved(liquidityReceiver, amount);
    }

    /**
     * @notice Withdraw accumulated USD24 to treasury account (9102) for rebalancing
     * @param amount Amount to withdraw
     */
    function withdrawUsd24(uint256 amount) external nonReentrant whenNotPaused onlyRole(LIQUIDITY_MANAGER_ROBOT_ROLE) {
        if (amount == 0) revert BufferPool__InvalidAmount();
        
        // Get the owner of treasury account (9102)
        address treasuryOwner = fiat24Account.ownerOf(TREASURY_ACCOUNT_ID);
        if (treasuryOwner == address(0)) revert BufferPool__ZeroAddress();
        
        IERC20Upgradeable(usd24).safeTransfer(treasuryOwner, amount);
        
        emit FiatTokensWithdrawn(usd24, treasuryOwner, amount);
    }

    /**
     * @notice Convert all accumulated fiat tokens to USD24 for treasury rebalancing
     * @param tokensIn Array of input fiat tokens to convert (must be valid and not USD24)
     * @param minAmountsOut Array of minimum USD24 outputs per token (slippage protection, 0 to skip)
     * @return totalAmountOut Total USD24 amount received from all conversions
     */
    function convertFiatToUsd24(
        address[] calldata tokensIn,
        uint256[] calldata minAmountsOut
    ) external nonReentrant whenNotPaused onlyRole(LIQUIDITY_MANAGER_ROBOT_ROLE) returns (uint256 totalAmountOut) {
        uint256 length = tokensIn.length;
        if (length == 0 || length != minAmountsOut.length) {
            revert BufferPool__InvalidAmount();
        }

        for (uint256 i = 0; i < length; i++) {
            address tokenIn = tokensIn[i];
            uint256 minAmountOut = minAmountsOut[i];

            if (!validXXX24Tokens[tokenIn]) revert BufferPool__InvalidToken();
            if (tokenIn == usd24) revert BufferPool__InvalidToken();

            // Get full balance of this token in the pool
            uint256 amountIn = IERC20Upgradeable(tokenIn).balanceOf(address(this));
            if (amountIn == 0) continue; // Skip if no balance

            // Approve fiat token to CryptoRelay
            IERC20Upgradeable(tokenIn).safeApprove(address(fiat24CryptoRelay), 0);
            IERC20Upgradeable(tokenIn).safeApprove(address(fiat24CryptoRelay), amountIn);

            // Execute exchange via Fiat24CryptoRelay
            uint256 amountOut = fiat24CryptoRelay.moneyExchangeExactIn(tokenIn, usd24, amountIn, minAmountOut);

            // Reset approval
            IERC20Upgradeable(tokenIn).safeApprove(address(fiat24CryptoRelay), 0);

            totalAmountOut += amountOut;
            emit FiatTokenConverted(tokenIn, amountIn, amountOut);
        }
    }

    /**
     * @notice Update fee settings
     * @param _bufferPoolFee New buffer pool fee in basis points
     */
    function updateFees(uint256 _bufferPoolFee) external onlyRole(OPERATOR_ROLE) {
        require(_bufferPoolFee <= 1000, "Fee too high"); // Max 10%
        if (_bufferPoolFee == bufferPoolFee) revert BufferPool__NoChange();
        uint256 oldFee = bufferPoolFee;
        bufferPoolFee = _bufferPoolFee;
        emit FeesUpdated(oldFee, _bufferPoolFee);
    }

    /**
     * @notice Update Stargate contract address
     * @param _stargate New stargate address
     */
    function updateStargate(address _stargate) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (_stargate == address(0)) revert BufferPool__ZeroAddress();
        if (_stargate == address(stargate)) revert BufferPool__NoChange();
        address oldStargate = address(stargate);
        stargate = IStargate(_stargate);
        emit StargateUpdated(oldStargate, _stargate);
    }

    /**
     * @notice Update destination onramp receiver contract (BufferPoolDst)
     * @param _dstOnrampReceiver New receiver address
     */
    function updateDstOnrampReceiver(uint32 _dstEid, address _dstOnrampReceiver) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (_dstOnrampReceiver == address(0)) revert BufferPool__ZeroAddress();
        if (_dstOnrampReceiver == dstOnrampReceivers[_dstEid]) revert BufferPool__NoChange();
        address oldReceiver = dstOnrampReceivers[_dstEid];
        dstOnrampReceivers[_dstEid] = _dstOnrampReceiver;
        emit DstOnrampReceiverUpdated(_dstEid, oldReceiver, _dstOnrampReceiver);
    }

    /**
     * @notice Update liquidity receiver address
     * @param _liquidityReceiver New receiver address
     */
    function updateLiquidityReceiver(address _liquidityReceiver) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (_liquidityReceiver == address(0)) revert BufferPool__ZeroAddress();
        if (_liquidityReceiver == liquidityReceiver) revert BufferPool__NoChange();
        address oldReceiver = liquidityReceiver;
        liquidityReceiver = _liquidityReceiver;
        emit LiquidityReceiverUpdated(oldReceiver, _liquidityReceiver);
    }

    /**
     * @notice Update fee receiver address
     * @param _feeReceiver New fee receiver address
     */
    function setFeeReceiver(address _feeReceiver) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (_feeReceiver == address(0)) revert BufferPool__ZeroAddress();
        if (_feeReceiver == feeReceiver) revert BufferPool__NoChange();
        address oldReceiver = feeReceiver;
        feeReceiver = _feeReceiver;
        emit FeeReceiverUpdated(oldReceiver, _feeReceiver);
    }

    /**
     * @notice Update Fiat24CryptoRelay contract address
     * @param _fiat24CryptoRelay New crypto relay address
     */
    function updateCryptoRelay(address _fiat24CryptoRelay) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (_fiat24CryptoRelay == address(0)) revert BufferPool__ZeroAddress();
        if (_fiat24CryptoRelay == address(fiat24CryptoRelay)) revert BufferPool__NoChange();
        address oldRelay = address(fiat24CryptoRelay);
        fiat24CryptoRelay = IFiat24CryptoRelay(_fiat24CryptoRelay);
        emit CryptoRelayUpdated(oldRelay, _fiat24CryptoRelay);
    }

    /**
     * @notice Enable a Fiat24 token for onramp
     * @param token Token address to enable
     */
    function enableFiat24Token(address token) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (token == address(0)) revert BufferPool__ZeroAddress();
        if (validXXX24Tokens[token]) revert BufferPool__NoChange();
        validXXX24Tokens[token] = true;
        emit Fiat24TokenValidityUpdated(token, false, true);
    }

    /**
     * @notice Disable a Fiat24 token for onramp
     * @param token Token address to disable
     */
    function disableFiat24Token(address token) external onlyRole(OPERATOR_ADMIN_ROLE) {
        if (token == address(0)) revert BufferPool__ZeroAddress();
        if (!validXXX24Tokens[token]) revert BufferPool__NoChange();
        validXXX24Tokens[token] = false;
        emit Fiat24TokenValidityUpdated(token, true, false);
    }

    /**
     * @notice Update default destination gas limit
     * @param _gasLimit New gas limit
     */
    function updateDefaultDstGasLimit(uint128 _gasLimit) external onlyRole(OPERATOR_ROLE) {
        if (_gasLimit == defaultDstGasLimit) revert BufferPool__NoChange();
        uint128 oldGasLimit = defaultDstGasLimit;
        defaultDstGasLimit = _gasLimit;
        emit DefaultDstGasLimitUpdated(oldGasLimit, _gasLimit);
    }

    function _executeSwap(SwapParams memory params, address recipient) internal returns (uint256 amountOut) {
        if (params.usdcAmount == 0) revert BufferPool__InvalidAmount();
        if (!whitelistedAggregators[params.aggregator]) revert BufferPool__NotWhitelistedAggregator();
        
        bytes4 selector = bytes4(params.swapCalldata);
        if (!whitelistedSelectors[params.aggregator][selector]) revert BufferPool__FunctionNotWhitelisted();

        // Deduct fee (skip minAmount check here, slippage is checked on output)
        uint256 swapAmount = _deductFeeAndValidate(params.usdcAmount, params.feeAmount, 0, recipient);

        bool isNativeOut = _isNativeToken(params.tokenOut);

        // Get balance before - for native token, track ETH balance directly
        uint256 balanceBefore = isNativeOut ? address(this).balance : IERC20Upgradeable(params.tokenOut).balanceOf(address(this));

        // Approve USDC to aggregator
        usdc.safeApprove(params.aggregator, 0);
        usdc.safeApprove(params.aggregator, swapAmount);

        // Execute swap via aggregator
        (bool success,) = params.aggregator.call(params.swapCalldata);
        
        // Reset approval
        usdc.safeApprove(params.aggregator, 0);
        
        if (!success) revert BufferPool__SwapFailed();

        // Calculate output amount
        uint256 balanceAfter = isNativeOut ? address(this).balance : IERC20Upgradeable(params.tokenOut).balanceOf(address(this));
        amountOut = balanceAfter - balanceBefore;

        // Check slippage on output
        if (amountOut < params.minAmountOut) revert BufferPool__SlippageExceeded();

        // Transfer output token to recipient
        if (isNativeOut) {
            _safeTransferETH(recipient, amountOut);
        } else {
            IERC20Upgradeable(params.tokenOut).safeTransfer(recipient, amountOut);
        }

        emit SwapExecuted(recipient, params.tokenOut, swapAmount, amountOut);
    }

    /**
     * @notice Add or remove aggregator from whitelist
     * @param _aggregator The aggregator contract address
     * @param _isWhitelisted True to whitelist, false to remove
     */
    function setAggregatorWhitelist(
        address _aggregator,
        bool _isWhitelisted
    ) external onlyRole(OPERATOR_ADMIN_ROLE) {
        require(_aggregator != address(0), "Invalid aggregator address");
        if (_isWhitelisted == whitelistedAggregators[_aggregator]) revert BufferPool__NoChange();
        whitelistedAggregators[_aggregator] = _isWhitelisted;
        emit AggregatorWhitelistUpdated(_aggregator, _isWhitelisted);
    }

    /**
     * @notice Add or remove function selector for a specific aggregator
     * @param _aggregator The aggregator contract address
     * @param _selector The function selector
     * @param _isWhitelisted True to whitelist, false to remove
     */
    function setFunctionSelector(
        address _aggregator,
        bytes4 _selector,
        bool _isWhitelisted
    ) external onlyRole(OPERATOR_ADMIN_ROLE) {
        require(_aggregator != address(0), "Invalid aggregator address");
        require(_selector != bytes4(0), "Invalid selector");
        require(whitelistedAggregators[_aggregator], "Aggregator not whitelisted");
        if (_isWhitelisted == whitelistedSelectors[_aggregator][_selector]) revert BufferPool__NoChange();
        whitelistedSelectors[_aggregator][_selector] = _isWhitelisted;
        emit FunctionSelectorWhitelisted(_aggregator, _selector, _isWhitelisted);
    }

    /**
     * @notice Pause the contract
     */
    function pause() external onlyRole(PAUSE_ROLE) {
        _pause();
    }

    /**
     * @notice Unpause the contract
     */
    function unpause() external onlyRole(UNPAUSE_ROLE) {
        _unpause();
    }

    /**
     * @notice Quote cross-chain fee and minimum received amount for Stargate sendToken
     * @param params Cross-chain onramp parameters (includes feeAmount to deduct)
     * @param usdcOut USDC amount before fee deduction (from getQuote)
     * @return nativeFee Native token fee required as msg.value for onrampAndBridge
     * @return minAmountLD Minimum amount to receive on destination (use as bridgeMinAmount)
     */
    function quoteCrossChainFee(
        CrossChainOnrampParams calldata params,
        uint256 usdcOut
    ) external view returns (uint256 nativeFee, uint256 minAmountLD) {
        if (params.dstEid == 0) revert BufferPool__InvalidDstEid();
        
        // Deduct fee from usdcOut (same as onrampAndBridge logic)
        if (params.feeAmount > 0 && usdcOut <= params.feeAmount) revert BufferPool__InvalidAmount();
        uint256 bridgeAmount = usdcOut - params.feeAmount;
        
        bytes memory composeMsg = _buildComposeMsg(params);
        uint128 dstGas = params.dstGasLimit == 0 ? defaultDstGasLimit : params.dstGasLimit;
        
        // Build extraOptions using OptionsBuilder for compose
        bytes memory extraOptions = OptionsBuilder.newOptions()
            .addExecutorLzComposeOption(0, dstGas, 0);

        address receiver = dstOnrampReceivers[params.dstEid];
        if (receiver == address(0)) revert BufferPool__ZeroAddress();

        SendParam memory sendParam = SendParam({
            dstEid: params.dstEid,
            to: _addressToBytes32(receiver),
            amountLD: bridgeAmount,
            minAmountLD: params.bridgeMinAmount,
            extraOptions: extraOptions,
            composeMsg: composeMsg,
            oftCmd: bytes("")
        });

        // Get OFT quote to calculate actual received amount (accounting for Stargate fees)
        (, , OFTReceipt memory receipt) = stargate.quoteOFT(sendParam);
        minAmountLD = receipt.amountReceivedLD;
        sendParam.minAmountLD = minAmountLD;

        // Get messaging fee
        MessagingFee memory fee = stargate.quoteSend(sendParam, false);
        nativeFee = fee.nativeFee;
    }

    function _sendCrossChain(
        CrossChainOnrampParams calldata params,
        uint256 usdcOut
    ) internal {
        if (params.dstEid == 0) revert BufferPool__InvalidDstEid();
        
        bytes memory composeMsg = _buildComposeMsg(params);
        uint128 dstGas = params.dstGasLimit == 0 ? defaultDstGasLimit : params.dstGasLimit;
        
        address receiver = dstOnrampReceivers[params.dstEid];
        if (receiver == address(0)) revert BufferPool__ZeroAddress();
        
        // Build extraOptions using OptionsBuilder for compose (taxi method)
        bytes memory extraOptions = OptionsBuilder.newOptions()
            .addExecutorLzComposeOption(0, dstGas, 0);

        SendParam memory sendParam = SendParam({
            dstEid: params.dstEid,
            to: _addressToBytes32(receiver),
            amountLD: usdcOut,
            minAmountLD: params.bridgeMinAmount, 
            extraOptions: extraOptions,
            composeMsg: composeMsg,
            oftCmd: bytes("")
        });

        // Approve USDC to Stargate
        usdc.safeApprove(address(stargate), 0);
        usdc.safeApprove(address(stargate), usdcOut);

        // Build fee struct - msg.value is the native fee for LayerZero messaging
        MessagingFee memory fee = MessagingFee({
            nativeFee: msg.value,
            lzTokenFee: 0
        });

        // Send via Stargate using sendToken (taxi method for composability)
        (, OFTReceipt memory oftReceipt, ) = stargate.sendToken{value: msg.value}(sendParam, fee, liquidityReceiver);

        // Verify the actual amount received matches the minimum expected
        if (oftReceipt.amountReceivedLD < params.bridgeMinAmount) revert BufferPool__SlippageExceeded();
    }

    function _buildComposeMsg(CrossChainOnrampParams calldata params) internal pure returns (bytes memory) {
        DstSwapPayload memory payload = DstSwapPayload({
            user: params.dstReceiver,
            tokenOut: params.dstTokenOut,
            minAmountOut: params.dstMinAmountOut,
            aggregator: params.dstAggregator,
            swapCalldata: params.dstSwapCalldata,
            srcTokenIn: params.tokenIn,
            srcAmountIn: params.amountIn
        });
        return abi.encode(payload);
    }

    function _addressToBytes32(address addr) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(addr)));
    }

    function _validateUserAccount(address user) internal view {
        uint256 tokenId = fiat24Account.historicOwnership(user);
        if (tokenId == 0 || !fiat24Account.exists(tokenId)) {
            revert BufferPool__AccountNotLive();
        }

        if (tokenId >= 9100 && tokenId <= 9199) {
            revert BufferPool__AccountNotSupport();
        }

        // Status.Live = 5
        if (fiat24Account.status(tokenId) != 5) {
            revert BufferPool__AccountNotLive();
        }
    }

    /**
     * @notice Deduct fee from amount, validate against minAmount, and transfer fee to feeReceiver
     * @param amount Total amount before fee
     * @param feeAmount Fee to deduct
     * @param minAmount Minimum acceptable amount after fee
     * @param user User address for event emission
     * @return netAmount Amount after fee deduction
     */
    function _deductFeeAndValidate(
        uint256 amount,
        uint256 feeAmount,
        uint256 minAmount,
        address user
    ) internal returns (uint256 netAmount) {
        // Validate fee doesn't exceed amount
        if (feeAmount > 0 && amount <= feeAmount) revert BufferPool__InvalidAmount();
        
        // Calculate net amount after fee
        netAmount = amount - feeAmount;
        if (netAmount < minAmount) revert BufferPool__SlippageExceeded();

        // Transfer fee to feeReceiver
        if (feeAmount > 0 && feeReceiver != address(0)) {
            usdc.safeTransfer(feeReceiver, feeAmount);
            emit FeeCollected(user, feeAmount);
        }
    }

    /// @notice Check if token address represents native ETH
    function _isNativeToken(address token) internal pure returns (bool) {
        return token == NATIVE_ETH || token == NATIVE_ETH_ALIAS;
    }

    /// @notice Safely transfer native ETH to recipient
    function _safeTransferETH(address to, uint256 amount) internal {
        (bool success, ) = to.call{value: amount}("");
        if (!success) revert BufferPool__NativeTransferFailed();
    }

    /**
     * @notice Transfer buffer pool fee to liquidityReceiver
     */
    function _collectBufferPoolFee(uint256 poolFeeAmount, address user) internal {
        if (poolFeeAmount == 0 || liquidityReceiver == address(0)) return;
        usdc.safeTransfer(liquidityReceiver, poolFeeAmount);
        emit BufferPoolFeeCollected(user, poolFeeAmount);
    }

    /**
     * @notice Execute swap or direct USDC transfer for onrampAndSwap
     */
    function _onrampSwapOrTransfer(
        address user,
        uint256 usdcOut,
        uint256 feeAmount,
        SwapParams calldata swapParams
    ) internal returns (uint256 amountOut) {
        if (swapParams.tokenOut == address(usdc)) {
            amountOut = _deductFeeAndValidate(usdcOut, feeAmount, swapParams.minAmountOut, user);
            usdc.safeTransfer(user, amountOut);
        } else {
            SwapParams memory swapParamsWithAmount = SwapParams({
                usdcAmount: usdcOut,
                feeAmount: feeAmount,
                tokenOut: swapParams.tokenOut,
                minAmountOut: swapParams.minAmountOut,
                aggregator: swapParams.aggregator,
                swapCalldata: swapParams.swapCalldata
            });
            amountOut = _executeSwap(swapParamsWithAmount, user);
        }
    }

    receive() external payable {}
}
